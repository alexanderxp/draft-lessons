<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<tittle>Title</tittle>
</head>

<body>
	<script>
    /* 1. Вернуть новый массив, состоящий из элементов, кратных их собственному индексу
во входном массиве (длина> 1).
Return a new array consisting of elements which are multiple of their own index 
in input array (length > 1).
Some cases:
[22, -6, 32, 82, 9, 25] => [-6, 32, 25]
[68, -1, 1, -7, 10, 10] => [-1, 10]
[-56,-85,72,-26,-14,76,-27,72,35,-21,-67,87,0,21,59,27,-92,68] => [-85, 72, 0, 68]
    */
     function multipleElementToIndex(arr) {
      return arr.filter((item, i)=> !i? 0: !(item % i));
     }
 // console.log(multipleElementToIndex([22, -6, 32, 82, 9, 25]));
		
    /* 2. Simple, remove the spaces from the string, then return the resultant string.
    */
     function removeSpacesFromString(str) {
      return str.replace(/\s/g, '');
     }
		
//console.log(multipleElementToIndex([22, -6, 32, 82, 9, 25]));
		
    /* 3. Remove First and Last Character It's pretty straightforward. 
Your goal is to create a function that removes the first 
and last characters of a string. You're given one parameter, 
the original string. 
You don't have to worry with strings with less than two characters.
    */
 function removeFirstLastFromString(str) {
  return str.slice(1, -1);
}
//console.log(removeFirstLastFromString('bambaleeeillllo'));

/* 4. In this kata, you must create a digital root function.
A digital root is the recursive sum of all the digits in a number. 
Given n, take the sum of the digits of n. If that value has more than one digit, 
continue reducing in this way until a single-digit number is produced. 
This is only applicable to the natural numbers.

Here's how it works:
digital_root(16)
=> 1 + 6
=> 7
digital_root(942)
=> 9 + 4 + 2
=> 15 ...
=> 1 + 5
=> 6
digital_root(132189)
=> 1 + 3 + 2 + 1 + 8 + 9
=> 24 ...
=> 2 + 4
=> 6
digital_root(493193)
=> 4 + 9 + 3 + 1 + 9 + 3
=> 29 ...
=> 2 + 9
=> 11 ...
=> 1 + 1
=> 2
*/
	function digitalRoot(number) {
		let result = 0;
		for (let i in String(number)) {
			result += Number(i);
		}
		return result;
	}
	
/* 5. Number is a palindrome if it is equal to the number with digits in reversed order. 
For example, 5, 44, 171, 4884 are palindromes and 43, 194, 4773 are not palindromes.
Write a method palindrome_chain_length which takes a positive number and returns 
the number of special steps needed to obtain a palindrome. 
The special step is: "reverse the digits, and add to the original number". 
If the resulting number is not a palindrome, repeat the procedure 
with the sum until the resulting number is a palindrome.
If the input number is already a palindrome, the number of steps is 0.

Input will always be a positive integer.
For example, start with 87:
87 + 78 = 165; 165 + 561 = 726; 726 + 627 = 1353; 1353 + 3531 = 4884
4884 is a palindrome and we needed 4 steps to obtain it, so palindrome_chain_length(87) == 4
*/
	function isPalindrome (array) {
		for (i = 0; i < array.length; i++) {
			if (array[i] !== array[array.length - i - 1]) {
			return false;
			}
		}
		return true;
	}
	
/* 6. The magic sum of 3s is calculated on an array 
by summing up odd numbers which include the digit 3. 
Write a function magic_sum which accepts an array of integers and returns the sum.
Example: [3, 12, 5, 8, 30, 13] results in 16 (3 + 13)
If the sum cannot be calculated, 0 should be returned.
из массива выбрать нечетные числа и выбрать числа 3
*/

	function magicSum(arr) {
		return arr.reduce(
			function (result, currentItem) {
			return currentItem & 1 && String(currentItem).search('3') != -1 ? result += currentItem : result;
			},0);
	}

	</script>
</body>

</html>